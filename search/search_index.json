{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Home automation India resources","title":"Home"},{"location":"#welcome-to-home-automation-india-resources","text":"","title":"Welcome to Home automation India resources"},{"location":"contributing/","text":"Principles Open documentaton: By design everything is read accessible to everyone on the planet Trust but maintain quality: Everyone who wants gets added with write permissions. However committing to main branch requires atleast 1 review to get their PRs merged. I am trusting the group as a whole to maintain high bar on quality when approving PRs. Well organized: We do a lot of things and everyone has different interests. We expect this repo to represent all of these over time but we still want it to be well organized for newbies. The contributing guidelines will keep updating to reflect the standards for best organization, please follow them. GPL v3 licensed: We spend time out of busy lives to build this documentation, we don't want people to use it and distribute as their product. All content is free and open source. Don't violate copyrights: Since this is publicly visible, we have more responsibility to not violate copyrights of others. Don't include images/videos with licenses without providing sufficient attribution. Link instead of downloading and sharing as your own. Pre-requisites: Learn Markdown Markdown is a lightweight and easy-to-use syntax for styling your writing. It includes conventions for Syntax highlighted code block # Header 1 ## Header 2 ### Header 3 - Bulleted - List 1. Numbered 2. List **Bold** and _Italic_ and `Code` text [Link](url) and ![Image](src) For more details see Basic writing and formatting syntax or Markdown cookbook Using Github editor Be comfortable in creating and editing files using the Github Editor Learn about Github branches and PR process Everyone contributing to the repo requires a PR for every change. Every PR requires atleast one approval from another member in this repo. Step 1 - Make a change Start editing use the Github editor, but do not commit to the main branch. Always create a new branch for your change. Recommendation is to do smaller changes for easier review by others, don't make 100 files in a single PR but similar related ones. Branch name should be: <username>-<readable name> . Eg while using this guide I used kunalgrover05-contributing-guide . Github Editor requires you to make only one commit per file. It is okay because finally while merging we will squash them all into a single commit for your branch. After you make your first commit, switch to using the branch you just created using these instructions . Make changes to other files in the same branch and keep adding good commit messages for everything. They will help you later. Step 2 - Raise a Pull Request Raise a pull request by going here and click on \"New pull request\". You can read more about PRs in this guide . Step 3 - Get a peer review Every change requires atleast one approval from another member of this repository. If you receive some feedback, you can address and make additional Step 1. Your PR should automatically get updated with new commits in your branch. Step 4 - Merge your changes Merge your changes using Squash and merge. Here you can create a good commit message using all the commits you created in Step 1. Creating a new tutorial A quick how-to for writing a new tutorial. - Step 1: Find the appropriate subdirectory to place it, create one if it doesn't exist already (see instructions below). - Step 2: Create a folder for your tutorial. You will use this folder to place all resources (images / YAML files etc.). Create a markdown file in this folder (maybe with the same name as folder). - Step 3: Create the documentation using markdown. - Step 4: Linking the doc in the navigation bar. Add the following to the top of your file. You can find the by going to the directory and looking for index.md file. --- parent: <ParentNameGoesHere> --- Creating a new Parent Create a new parent if you don't find any meaningful grouping to add your tutorial to. - Step 1: Create a root directory for the parent. eg: create a directory called linux - Step 2: Create index.md within the parent with the following content --- has_children: true title: <MeaningfulNameHere> ---","title":"Contributing"},{"location":"contributing/#principles","text":"Open documentaton: By design everything is read accessible to everyone on the planet Trust but maintain quality: Everyone who wants gets added with write permissions. However committing to main branch requires atleast 1 review to get their PRs merged. I am trusting the group as a whole to maintain high bar on quality when approving PRs. Well organized: We do a lot of things and everyone has different interests. We expect this repo to represent all of these over time but we still want it to be well organized for newbies. The contributing guidelines will keep updating to reflect the standards for best organization, please follow them. GPL v3 licensed: We spend time out of busy lives to build this documentation, we don't want people to use it and distribute as their product. All content is free and open source. Don't violate copyrights: Since this is publicly visible, we have more responsibility to not violate copyrights of others. Don't include images/videos with licenses without providing sufficient attribution. Link instead of downloading and sharing as your own.","title":"Principles"},{"location":"contributing/#pre-requisites","text":"","title":"Pre-requisites:"},{"location":"contributing/#learn-markdown","text":"Markdown is a lightweight and easy-to-use syntax for styling your writing. It includes conventions for Syntax highlighted code block # Header 1 ## Header 2 ### Header 3 - Bulleted - List 1. Numbered 2. List **Bold** and _Italic_ and `Code` text [Link](url) and ![Image](src) For more details see Basic writing and formatting syntax or Markdown cookbook","title":"Learn Markdown"},{"location":"contributing/#using-github-editor","text":"Be comfortable in creating and editing files using the Github Editor","title":"Using Github editor"},{"location":"contributing/#learn-about-github-branches-and-pr-process","text":"Everyone contributing to the repo requires a PR for every change. Every PR requires atleast one approval from another member in this repo.","title":"Learn about Github branches and PR process"},{"location":"contributing/#step-1-make-a-change","text":"Start editing use the Github editor, but do not commit to the main branch. Always create a new branch for your change. Recommendation is to do smaller changes for easier review by others, don't make 100 files in a single PR but similar related ones. Branch name should be: <username>-<readable name> . Eg while using this guide I used kunalgrover05-contributing-guide . Github Editor requires you to make only one commit per file. It is okay because finally while merging we will squash them all into a single commit for your branch. After you make your first commit, switch to using the branch you just created using these instructions . Make changes to other files in the same branch and keep adding good commit messages for everything. They will help you later.","title":"Step 1 - Make a change"},{"location":"contributing/#step-2-raise-a-pull-request","text":"Raise a pull request by going here and click on \"New pull request\". You can read more about PRs in this guide .","title":"Step 2 - Raise a Pull Request"},{"location":"contributing/#step-3-get-a-peer-review","text":"Every change requires atleast one approval from another member of this repository. If you receive some feedback, you can address and make additional Step 1. Your PR should automatically get updated with new commits in your branch.","title":"Step 3 - Get a peer review"},{"location":"contributing/#step-4-merge-your-changes","text":"Merge your changes using Squash and merge. Here you can create a good commit message using all the commits you created in Step 1.","title":"Step 4 - Merge your changes"},{"location":"contributing/#creating-a-new-tutorial","text":"A quick how-to for writing a new tutorial. - Step 1: Find the appropriate subdirectory to place it, create one if it doesn't exist already (see instructions below). - Step 2: Create a folder for your tutorial. You will use this folder to place all resources (images / YAML files etc.). Create a markdown file in this folder (maybe with the same name as folder). - Step 3: Create the documentation using markdown. - Step 4: Linking the doc in the navigation bar. Add the following to the top of your file. You can find the by going to the directory and looking for index.md file. --- parent: <ParentNameGoesHere> ---","title":"Creating a new tutorial"},{"location":"contributing/#creating-a-new-parent","text":"Create a new parent if you don't find any meaningful grouping to add your tutorial to. - Step 1: Create a root directory for the parent. eg: create a directory called linux - Step 2: Create index.md within the parent with the following content --- has_children: true title: <MeaningfulNameHere> ---","title":"Creating a new Parent"},{"location":"google28551c3be168a461/","text":"","title":"Google28551c3be168a461"},{"location":"debugging/","text":"This section contains details about debugging in various platforms / services.","title":"Debugging"},{"location":"debugging/debugging-mqtt/","text":"Debugging MQTT MQTT explorer is a great tool for viewing all topics on your MQTT server and debug what's going wrong.","title":"Debugging MQTT"},{"location":"debugging/debugging-mqtt/#debugging-mqtt","text":"MQTT explorer is a great tool for viewing all topics on your MQTT server and debug what's going wrong.","title":"Debugging MQTT"},{"location":"docker-and-self-hosted-apps/","text":"","title":"Docker"},{"location":"docker-and-self-hosted-apps/heimdall/","text":"How to add custom apps to Heimdall - The proper method What is Heimdall? Heimdall is a self-hosted personal dashboard. It acts as a dashboard that hosts links to all your self-hosted, or online apps and app instances. See the screenshot bellow to get an idea. Why Do You Need This? Heimdall comes preloaded with many foundation and enhanced apps. However, one may find that not all apps are there. Not to worry. There is a huge community supporting ongoing development of Heimdall, and some of them have been kind enough to make their own versions of apps, which are not available in Heimdall out of the box. We can easily make them available in Heimdall with a few lines of commands NOTE: This guide is only applicable to the docker installation. You may adapt the steps in a normal installation too. The official installation offers many apps for the dashboard, but there are numerous more, developed by the community. These apps can be added by following this method. Heimdall Home Page For this guide, I will use the example of Omada SDN Controller. First, go to Heimdall App Request List and check if the desired app is available in the page. NOTE : Only apps made avaiable in this page can be used with this method. Steps Locate the app and ownload the file; let's take the example of Omada. You will see two columns with names of Foundation App and Enhanced App . Right click on the link, copy link, and use: wget https://apps.heimdall.site/request/enhanced/aeddfb31b642e8e30591a99b3b3c30b8a765be32 Now, unzip the file. unzip OmadaSDNController.zip Transfer the file to docker-data path. In your case case, this is home/seetendra/docker_volumes/heimdall/config/www/SupportedApps - You can use a samba share or use terminal. In terminal, you can use the cp command. e.g., sudo cp -r OmadaSDNController docker_volumes/heimdall/config/www/SupportedApps/OmadaSDNController This has to go to the docker path of Heimdall. In may case, it is stored in my Home Folder -> docker_volumes folder Once the folder is added to the supported apps folder in Heimdall, lets get inside the container. Either use Portainer to get inside the container, or use terminal to do so. E.g., docker exec -it heimdall /bin/bash Alternatively, you can use Portainer to get inside the container And then do the following to change to the heimdall core directory inside docker: cd /var/www/localhost/heimdall/ Next, we need to create a new folder. We need to use the folder name, exactly as the original file name. Here, it is OmadaSDNController php artisan register:app OmadaSDNController That's about it. Now, you can head over to Heimdall and add this app from the drop down list. It should show up in the drop down.","title":"How to add custom apps to Heimdall - The proper method"},{"location":"docker-and-self-hosted-apps/heimdall/#how-to-add-custom-apps-to-heimdall-the-proper-method","text":"","title":"How to add custom apps to Heimdall - The proper method"},{"location":"docker-and-self-hosted-apps/heimdall/#what-is-heimdall","text":"Heimdall is a self-hosted personal dashboard. It acts as a dashboard that hosts links to all your self-hosted, or online apps and app instances. See the screenshot bellow to get an idea.","title":"What is Heimdall?"},{"location":"docker-and-self-hosted-apps/heimdall/#why-do-you-need-this","text":"Heimdall comes preloaded with many foundation and enhanced apps. However, one may find that not all apps are there. Not to worry. There is a huge community supporting ongoing development of Heimdall, and some of them have been kind enough to make their own versions of apps, which are not available in Heimdall out of the box. We can easily make them available in Heimdall with a few lines of commands NOTE: This guide is only applicable to the docker installation. You may adapt the steps in a normal installation too. The official installation offers many apps for the dashboard, but there are numerous more, developed by the community. These apps can be added by following this method. Heimdall Home Page For this guide, I will use the example of Omada SDN Controller. First, go to Heimdall App Request List and check if the desired app is available in the page. NOTE : Only apps made avaiable in this page can be used with this method.","title":"Why Do You Need This?"},{"location":"docker-and-self-hosted-apps/heimdall/#steps","text":"Locate the app and ownload the file; let's take the example of Omada. You will see two columns with names of Foundation App and Enhanced App . Right click on the link, copy link, and use: wget https://apps.heimdall.site/request/enhanced/aeddfb31b642e8e30591a99b3b3c30b8a765be32 Now, unzip the file. unzip OmadaSDNController.zip Transfer the file to docker-data path. In your case case, this is home/seetendra/docker_volumes/heimdall/config/www/SupportedApps - You can use a samba share or use terminal. In terminal, you can use the cp command. e.g., sudo cp -r OmadaSDNController docker_volumes/heimdall/config/www/SupportedApps/OmadaSDNController This has to go to the docker path of Heimdall. In may case, it is stored in my Home Folder -> docker_volumes folder Once the folder is added to the supported apps folder in Heimdall, lets get inside the container. Either use Portainer to get inside the container, or use terminal to do so. E.g., docker exec -it heimdall /bin/bash Alternatively, you can use Portainer to get inside the container And then do the following to change to the heimdall core directory inside docker: cd /var/www/localhost/heimdall/ Next, we need to create a new folder. We need to use the folder name, exactly as the original file name. Here, it is OmadaSDNController php artisan register:app OmadaSDNController That's about it. Now, you can head over to Heimdall and add this app from the drop down list. It should show up in the drop down.","title":"Steps"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/install-authelia/","text":"Authelia Installation Prerequisites Must have completed Install Traefik What is Authelia Authelia is an open-source authentication and authorization server protecting modern web applications by collaborating with reverse proxies such as NGINX, Traefik and HAProxy. Consequently, no code is required to protect your apps. What does it do? Enable your users to login once and access everything. Authelia Official Website Configuration Authelia configs will be stored at /mnt/dietpi_userdata/Authelia/config Here we are creating 2 middlwares - authelia - authelia-basic authelia will be used for normal GUI auth. authelia-basic will use used for http auth (The good old login prompt). Installation mkdir -p /mnt/dietpi_userdata/Authelia/config Create configuration file nano /mnt/dietpi_userdata/Authelia/config/configuration.yml You need to change the following secrets. jwt_secret Session secret ############################################################################## # Authelia configuration sourced from thehomelab.wiki # ############################################################################## log: level: info jwt_secret: 2cCBR773wDpe45FPCPmgB # replace this default_redirection_url: https://login.lan.siddhu.dev totp: issuer: siddhu.dev period: 30 skew: 1 #duo_api: ## If you want push notifictions of login attempts you can pay for this feature # hostname: api-123456789.example.com # integration_key: ABCDEF # secret_key: yet-another-long-string-of-characters-and-numbers-and-symbols server: ## The address to listen on. host: 0.0.0.0 ## The port to listen on. port: 9091 ## Set the single level path Authelia listens on. ## Must be alphanumeric chars and should not contain any slashes. path: \"\" ## Buffers usually should be configured to be the same value. ## Explanation at https://www.authelia.com/docs/configuration/server.html ## Read buffer size adjusts the server's max incoming request size in bytes. ## Write buffer size does the same for outgoing responses. read_buffer_size: 4096 write_buffer_size: 4096 ## Enables the pprof endpoint. enable_pprof: false ## Enables the expvars endpoint. enable_expvars: false ## Disables writing the health check vars to /app/.healthcheck.env which makes healthcheck.sh return exit code 0. ## This is disabled by default if either /app/.healthcheck.env or /app/healthcheck.sh do not exist. disable_healthcheck: false ## Authelia by default doesn't accept TLS communication on the server port. This section overrides this behaviour. tls: ## The path to the DER base64/PEM format private key. key: \"\" ## The path to t authentication_backend: disable_reset_password: false file: path: /config/users_database.yml # Make sure this file exists password: algorithm: argon2id iterations: 1 salt_length: 16 parallelism: 8 memory: 64 access_control: default_policy: deny rules: # Rules applied to everyone - domain: - \"login.lan.siddhu.dev\" policy: bypass - domain: # Proxies only requiring username and password - \"*.lan.siddhu.dev\" policy: one_factor # networks: # - 192.168.1.0/24 # - domain: # Proxies needing 2 factor below # - \"proxmox.yourdomain.com\" # policy: two_factor # networks: # - 192.168.1.0/24 session: name: authelia_session # This secret can also be set using the env variables AUTHELIA_SESSION_SECRET_FILE secret: l2b33jzfzvdvp2esrdhro7n40w # replace this expiration: 3600 # 1 hour inactivity: 7200 # 2 hours domain: siddhu.dev # Needs to be your root domain redis: host: authelia_redis port: 6379 # This secret can also be set using the env variables AUTHELIA_SESSION_REDIS_PASSWORD_FILE # password: authelia regulation: max_retries: 5 find_time: 2m ban_time: 10m theme: dark # options: dark, light storage: local: path: /config/db.sqlite3 notifier: filesystem: filename: /config/notification.txt # smtp: # username: <your-user@your-email-domain.org> # password: <your-user-email-password-for-smtp> # host: <your-email-host-url-or-ip> # port: <your-email-port-for-smtp> # 25 non-ssl, 443 ssl, 587 tls # sender: <sender@your-email-domain.org> # subject: \"[Authelia] {title}\" # disable_require_tls: false # set to true if your domain uses no tls or ssl only # disable_html_emails: false # set to true if you don't want html in your emails # tls: # server_name: <your-email-host-url-or-ip> # skip_verify: false # minimum_version: TLS1.2 ntp: ## NTP server address. address: \"time.cloudflare.com:123\" ## NTP version. version: 4 ## Maximum allowed time offset between the host and the NTP server. max_desync: 3s ## Disables the NTP check on startup entirely. This means Authelia will not contact a remote service at all if you ## set this to true, and can operate in a truly offline mode. disable_startup_check: false ## The default of false will prevent startup only if we can contact the NTP server and the time is out of sync with ## the NTP server more than the configured max_desync. If you set this to true, an error will be logged but startup ## will continue regardless of results. disable_failure: false Create user nano /mnt/dietpi_userdata/Authelia/config/users_database.yml Generate a password and replace mysecretpass with your password $ echo `sudo docker run authelia/authelia:latest authelia hash-password 'mysecretpass' | awk '{print $3}''Your new Password Here'` $argon2id$v=19$m=65536,t=1,p=8$M2RWN1JiZjQyT0hkdGl0Uw$qXUbJJW3e4Z+G4mrslQC27mW4+2Kfgj0F3won2cRUOc The following file has a user sampleuser Copy and replace generated password in the field password ############################################################### # Users Database # ############################################################### # This file can be used if you do not have an LDAP set up. # List of users users: sampleuser: displayname: \"Authelia User\" # Password is authelia password: \"$argon2id$v=19$m=65536,t=1,p=8$M2RWN1JiZjQyT0hkdGl0Uw$qXUbJJW3e4Z+G4mrslQC27mW4+2Kfgj0F3won2cRUOc\" # yamllint disable-line rule:line-length email: authelia@authelia.com groups: - admins - dev Create a stack version: '3.3' services: authelia: image: authelia/authelia container_name: authelia_main volumes: - /mnt/dietpi_userdata/Authelia/config:/config #ports: # - 9091:9091 restart: unless-stopped healthcheck: disable: true environment: - TZ=Asia/Kolkata depends_on: - redis networks: - traefik-public - default labels: - 'traefik.enable=true' - 'traefik.http.routers.authelia.rule=Host(`login.lan.siddhu.dev`)' - 'traefik.http.routers.authelia.entrypoints=websecure' - \"traefik.http.routers.authelia.tls.certresolver=letsencrypt\" - 'traefik.http.routers.authelia.tls=true' - \"traefik.docker.network=traefik-public\" - 'traefik.http.services.authelia.loadbalancer.server.port=9091' - 'traefik.http.middlewares.authelia.forwardauth.address=http://authelia:9091/api/verify?rd=https://login.lan.siddhu.dev/' - 'traefik.http.middlewares.authelia.forwardauth.trustForwardHeader=true' - 'traefik.http.middlewares.authelia.forwardauth.authResponseHeaders=Remote-User, Remote-Groups, Remote-Name, Remote-Email' - 'traefik.http.middlewares.authelia-basic.forwardauth.address=http://authelia:9091/api/verify?auth=basic' - 'traefik.http.middlewares.authelia-basic.forwardauth.trustForwardHeader=true' - 'traefik.http.middlewares.authelia-basic.forwardauth.authResponseHeaders=Remote-User, Remote-Groups, Remote-Name, Remote-Email' redis: image: redis:alpine container_name: authelia_redis volumes: - /mnt/dietpi_userdata/Authelia/redis:/data expose: - 6379 restart: unless-stopped environment: - TZ=Asia/Kolkata networks: - default networks: default: driver: bridge traefik-public: external: true In just a few seconds you can see it in the dashboard Naviate to your login URL https://login.lan.siddhu.dev/ Try loggin in , if everything gone well you will see the screen below. Integrating Docker + Authelia to existing stacks Here is simple dozzle docker which lets you analyse the logs , it does not come with any login. version: \"3\" services: dozzle: container_name: dozzle image: amir20/dozzle:latest volumes: - /var/run/docker.sock:/var/run/docker.sock #ports: # - 9999:8080 labels: - \"traefik.enable=true\" - \"traefik.http.routers.dozzle.rule=Host(`dozzle.lan.siddhu.dev`)\" - \"traefik.http.routers.dozzle.entrypoints=websecure\" - \"traefik.http.routers.dozzle.tls.certresolver=letsencrypt\" - \"traefik.http.routers.dozzle.tls=true\" - \"traefik.http.routers.dozzle.middlewares=authelia@docker\" - \"traefik.http.services.dozzle.loadbalancer.server.port=8080\" - \"traefik.docker.network=traefik-public\" restart: unless-stopped networks: - traefik-public networks: traefik-public: external: true After few seconds it will show on the traefik dashboard Then you can access https://dozzle.lan.siddhu.dev After login","title":"Authelia Installation"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/install-authelia/#authelia-installation","text":"","title":"Authelia Installation"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/install-authelia/#prerequisites","text":"Must have completed Install Traefik","title":"Prerequisites"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/install-authelia/#what-is-authelia","text":"Authelia is an open-source authentication and authorization server protecting modern web applications by collaborating with reverse proxies such as NGINX, Traefik and HAProxy. Consequently, no code is required to protect your apps.","title":"What is Authelia"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/install-authelia/#what-does-it-do","text":"Enable your users to login once and access everything. Authelia Official Website","title":"What does it do?"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/install-authelia/#configuration","text":"Authelia configs will be stored at /mnt/dietpi_userdata/Authelia/config Here we are creating 2 middlwares - authelia - authelia-basic authelia will be used for normal GUI auth. authelia-basic will use used for http auth (The good old login prompt).","title":"Configuration"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/install-authelia/#installation","text":"mkdir -p /mnt/dietpi_userdata/Authelia/config Create configuration file nano /mnt/dietpi_userdata/Authelia/config/configuration.yml You need to change the following secrets. jwt_secret Session secret ############################################################################## # Authelia configuration sourced from thehomelab.wiki # ############################################################################## log: level: info jwt_secret: 2cCBR773wDpe45FPCPmgB # replace this default_redirection_url: https://login.lan.siddhu.dev totp: issuer: siddhu.dev period: 30 skew: 1 #duo_api: ## If you want push notifictions of login attempts you can pay for this feature # hostname: api-123456789.example.com # integration_key: ABCDEF # secret_key: yet-another-long-string-of-characters-and-numbers-and-symbols server: ## The address to listen on. host: 0.0.0.0 ## The port to listen on. port: 9091 ## Set the single level path Authelia listens on. ## Must be alphanumeric chars and should not contain any slashes. path: \"\" ## Buffers usually should be configured to be the same value. ## Explanation at https://www.authelia.com/docs/configuration/server.html ## Read buffer size adjusts the server's max incoming request size in bytes. ## Write buffer size does the same for outgoing responses. read_buffer_size: 4096 write_buffer_size: 4096 ## Enables the pprof endpoint. enable_pprof: false ## Enables the expvars endpoint. enable_expvars: false ## Disables writing the health check vars to /app/.healthcheck.env which makes healthcheck.sh return exit code 0. ## This is disabled by default if either /app/.healthcheck.env or /app/healthcheck.sh do not exist. disable_healthcheck: false ## Authelia by default doesn't accept TLS communication on the server port. This section overrides this behaviour. tls: ## The path to the DER base64/PEM format private key. key: \"\" ## The path to t authentication_backend: disable_reset_password: false file: path: /config/users_database.yml # Make sure this file exists password: algorithm: argon2id iterations: 1 salt_length: 16 parallelism: 8 memory: 64 access_control: default_policy: deny rules: # Rules applied to everyone - domain: - \"login.lan.siddhu.dev\" policy: bypass - domain: # Proxies only requiring username and password - \"*.lan.siddhu.dev\" policy: one_factor # networks: # - 192.168.1.0/24 # - domain: # Proxies needing 2 factor below # - \"proxmox.yourdomain.com\" # policy: two_factor # networks: # - 192.168.1.0/24 session: name: authelia_session # This secret can also be set using the env variables AUTHELIA_SESSION_SECRET_FILE secret: l2b33jzfzvdvp2esrdhro7n40w # replace this expiration: 3600 # 1 hour inactivity: 7200 # 2 hours domain: siddhu.dev # Needs to be your root domain redis: host: authelia_redis port: 6379 # This secret can also be set using the env variables AUTHELIA_SESSION_REDIS_PASSWORD_FILE # password: authelia regulation: max_retries: 5 find_time: 2m ban_time: 10m theme: dark # options: dark, light storage: local: path: /config/db.sqlite3 notifier: filesystem: filename: /config/notification.txt # smtp: # username: <your-user@your-email-domain.org> # password: <your-user-email-password-for-smtp> # host: <your-email-host-url-or-ip> # port: <your-email-port-for-smtp> # 25 non-ssl, 443 ssl, 587 tls # sender: <sender@your-email-domain.org> # subject: \"[Authelia] {title}\" # disable_require_tls: false # set to true if your domain uses no tls or ssl only # disable_html_emails: false # set to true if you don't want html in your emails # tls: # server_name: <your-email-host-url-or-ip> # skip_verify: false # minimum_version: TLS1.2 ntp: ## NTP server address. address: \"time.cloudflare.com:123\" ## NTP version. version: 4 ## Maximum allowed time offset between the host and the NTP server. max_desync: 3s ## Disables the NTP check on startup entirely. This means Authelia will not contact a remote service at all if you ## set this to true, and can operate in a truly offline mode. disable_startup_check: false ## The default of false will prevent startup only if we can contact the NTP server and the time is out of sync with ## the NTP server more than the configured max_desync. If you set this to true, an error will be logged but startup ## will continue regardless of results. disable_failure: false","title":"Installation"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/install-authelia/#create-user","text":"nano /mnt/dietpi_userdata/Authelia/config/users_database.yml Generate a password and replace mysecretpass with your password $ echo `sudo docker run authelia/authelia:latest authelia hash-password 'mysecretpass' | awk '{print $3}''Your new Password Here'` $argon2id$v=19$m=65536,t=1,p=8$M2RWN1JiZjQyT0hkdGl0Uw$qXUbJJW3e4Z+G4mrslQC27mW4+2Kfgj0F3won2cRUOc The following file has a user sampleuser Copy and replace generated password in the field password ############################################################### # Users Database # ############################################################### # This file can be used if you do not have an LDAP set up. # List of users users: sampleuser: displayname: \"Authelia User\" # Password is authelia password: \"$argon2id$v=19$m=65536,t=1,p=8$M2RWN1JiZjQyT0hkdGl0Uw$qXUbJJW3e4Z+G4mrslQC27mW4+2Kfgj0F3won2cRUOc\" # yamllint disable-line rule:line-length email: authelia@authelia.com groups: - admins - dev","title":"Create user"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/install-authelia/#create-a-stack","text":"version: '3.3' services: authelia: image: authelia/authelia container_name: authelia_main volumes: - /mnt/dietpi_userdata/Authelia/config:/config #ports: # - 9091:9091 restart: unless-stopped healthcheck: disable: true environment: - TZ=Asia/Kolkata depends_on: - redis networks: - traefik-public - default labels: - 'traefik.enable=true' - 'traefik.http.routers.authelia.rule=Host(`login.lan.siddhu.dev`)' - 'traefik.http.routers.authelia.entrypoints=websecure' - \"traefik.http.routers.authelia.tls.certresolver=letsencrypt\" - 'traefik.http.routers.authelia.tls=true' - \"traefik.docker.network=traefik-public\" - 'traefik.http.services.authelia.loadbalancer.server.port=9091' - 'traefik.http.middlewares.authelia.forwardauth.address=http://authelia:9091/api/verify?rd=https://login.lan.siddhu.dev/' - 'traefik.http.middlewares.authelia.forwardauth.trustForwardHeader=true' - 'traefik.http.middlewares.authelia.forwardauth.authResponseHeaders=Remote-User, Remote-Groups, Remote-Name, Remote-Email' - 'traefik.http.middlewares.authelia-basic.forwardauth.address=http://authelia:9091/api/verify?auth=basic' - 'traefik.http.middlewares.authelia-basic.forwardauth.trustForwardHeader=true' - 'traefik.http.middlewares.authelia-basic.forwardauth.authResponseHeaders=Remote-User, Remote-Groups, Remote-Name, Remote-Email' redis: image: redis:alpine container_name: authelia_redis volumes: - /mnt/dietpi_userdata/Authelia/redis:/data expose: - 6379 restart: unless-stopped environment: - TZ=Asia/Kolkata networks: - default networks: default: driver: bridge traefik-public: external: true In just a few seconds you can see it in the dashboard","title":"Create a stack"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/install-authelia/#naviate-to-your-login-url","text":"https://login.lan.siddhu.dev/ Try loggin in , if everything gone well you will see the screen below.","title":"Naviate to your login URL"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/install-authelia/#integrating-docker-authelia-to-existing-stacks","text":"Here is simple dozzle docker which lets you analyse the logs , it does not come with any login. version: \"3\" services: dozzle: container_name: dozzle image: amir20/dozzle:latest volumes: - /var/run/docker.sock:/var/run/docker.sock #ports: # - 9999:8080 labels: - \"traefik.enable=true\" - \"traefik.http.routers.dozzle.rule=Host(`dozzle.lan.siddhu.dev`)\" - \"traefik.http.routers.dozzle.entrypoints=websecure\" - \"traefik.http.routers.dozzle.tls.certresolver=letsencrypt\" - \"traefik.http.routers.dozzle.tls=true\" - \"traefik.http.routers.dozzle.middlewares=authelia@docker\" - \"traefik.http.services.dozzle.loadbalancer.server.port=8080\" - \"traefik.docker.network=traefik-public\" restart: unless-stopped networks: - traefik-public networks: traefik-public: external: true After few seconds it will show on the traefik dashboard Then you can access https://dozzle.lan.siddhu.dev After login","title":"Integrating Docker + Authelia to existing stacks"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/the-traefik-stack/","text":"The Traefik - Authelia Docker SSO Stack What is Traefik? The simplest, most comprehensive cloud-native stack to help enterprises manage their entire network across data centers, on-premises servers and public clouds all the way out to the edge. Traefik Official Website Why should you use it? If you want to run several containers on a single server and have more than one of them respond to web traffic, you have to use a reverse proxy like Traefik. Basics Traefik Providers Traefik supports different types of providers to supply configuration to it. We are using Docker provider and File provider here. Docker Provider It is used to configure our proxy through Docker labels. File Provider Since Docker provider does not support proxying external URLs we are using the file provider. Prerequisite A Machine with docker and docker-compose installed Cloudflare account (Optional). Portainer (Optional) Running Home Assistant Docker stack Lots of patience My setup Raspberry Pi 4 - 4G running DietPi WD Green 240 GB SSD Connected Amazon Orico Enclosure USB3.1 Gen 2 Amazon Connected via Ethernet Traefik Installation My storage location will be /mnt/dietpi_userdata/traefik The domain I will be using is lan.siddhu.dev Get CloudFlare token Login to CloudFlare Click on the User Icon on the right top. Navigate to API Tokens . Click on Vew next to Global API Key . Complete captcha if shown. Copy the key to use with stack below. Create a dedicated network for connecting all containers and stacks $ sudo docker network create --driver=bridge --attachable traefik-public 725626e1ece9d2b292a551c441140a94c23a24588860022998ebf83f9b403cf7 You can create a network in Portainer from Networks -> Add Network , Select Driver Bridge, and turn on Enable manual container attachment Create Traefik stack Important Notes: The Traefik itself will be using traefik.lan.siddhu.dev domain . Traefik requires you to define \"Certificate Resolvers\" in the configuration, which is responsible for retrieving certificates from an ACME server. We will be using the resolver name letsencrypt , just a name you can use anything. The configuration below is used to create a wildcard cert for all domains under lan.siddhu.dev since LetsEncrypt comes with rate limits . - 'traefik.http.routers.traefik.tls.domains[0].main=lan.siddhu.dev' - 'traefik.http.routers.traefik.tls.domains[0].sans=*.lan.siddhu.dev' In Dynamic Configuration local-ip should be replaced with your Raspberry Pi / VM IP, this once is used for proxying all the devices running in the docker host network. All docker containers are configured through the Portainer itself. Create folders mkdir -p /mnt/dietpi_userdata/traefik/confs nano /mnt/dietpi_userdata/traefik/confs/traefik.yml ## traefik.yml # Docker configuration backend providers: docker: endpoint: \"unix:///var/run/docker.sock\" exposedByDefault: false file: directory: \"/etc/traefik\" watch: true # API and dashboard configuration api: insecure: true entryPoints: web: address: \":80\" http: redirections: # Force redirect to https entryPoint: permanent: true to: websecure scheme: https websecure: address: \":443\" certificatesResolvers: letsencrypt: acme: #caServer: https://acme-staging-v02.api.letsencrypt.org/directory storage: /letsencrypt/acme.json email: your-email@gmail.com dnschallenge: provider: cloudflare ## DYNAMIC CONFIGURATION http: routers: esphome: rule: \"Host(`esphome.lan.siddhu.dev`)\" service: esphome-service priority: 1000 tls: certresolver: letsencrypt entryPoints: - websecure homeassistant: rule: \"Host(`ha.lan.siddhu.dev`)\" service: homeassistant-service priority: 1000 tls: certresolver: letsencrypt entryPoints: - websecure services: esphome-service: loadBalancer: servers: - url: \"http://local-ip:6052\" homeassistant-service: loadBalancer: servers: - url: \"http://local-ip:8123\" Create a new stack named traefik in portainer version: \"3.3\" services: traefik: image: \"traefik:v2.5\" container_name: \"traefik\" labels: - 'traefik.enable=true' - 'traefik.http.routers.traefik.rule=Host(`traefik.lan.siddhu.dev`)' - 'traefik.http.routers.traefik.entrypoints=websecure' - \"traefik.http.routers.traefik.tls.certresolver=letsencrypt\" - 'traefik.http.routers.traefik.tls=true' - 'traefik.http.routers.traefik.tls.domains[0].main=lan.siddhu.dev' - 'traefik.http.routers.traefik.tls.domains[0].sans=*.lan.siddhu.dev' - 'traefik.http.services.traefik.loadbalancer.server.port=8080' - \"traefik.docker.network=traefik-public\" environment: - \"CF_API_EMAIL=your-email@gmail.com\" - \"CF_API_KEY=cloudflare-api-key-here\" ports: - \"80:80\" - \"443:443\" - \"8080:8080\" volumes: - \"/mnt/dietpi_userdata/traefik/letsencrypt:/letsencrypt\" # used for storing certifcates and l3 related data - \"/mnt/dietpi_userdata/traefik/confs:/etc/traefik\" # file provider for Traefik - \"/var/run/docker.sock:/var/run/docker.sock:ro\" restart: unless-stopped networks: - traefik-public networks: traefik-public: external: true Check with browser Open the url traefik.lan.siddhu.dev in browser, it may throw SSL error for few minutes. If it happends try after 1 or 2 minutes. If everything goes well procced to next step Creating a new Proxy with Traefik Dozzle is a log viewer for docker containers. Let deploy one with SSL cert in Treafik version: \"3\" services: dozzle: container_name: dozzle image: amir20/dozzle:latest volumes: - /var/run/docker.sock:/var/run/docker.sock #ports: # - 9999:8080 labels: - \"traefik.enable=true\" - \"traefik.http.routers.dozzle.rule=Host(`dozzle.lan.siddhu.dev`)\" - \"traefik.http.routers.dozzle.entrypoints=websecure\" - \"traefik.http.routers.dozzle.tls.certresolver=letsencrypt\" - \"traefik.http.routers.dozzle.tls=true\" - \"traefik.http.routers.dozzle.middlewares=authelia@docker\" - \"traefik.http.services.dozzle.loadbalancer.server.port=8080\" - \"traefik.docker.network=traefik-public\" restart: unless-stopped networks: - traefik-public networks: traefik-public: external: true Within a few seconds it will appear on Traefik dashboard and you can use it with the URL dozzle.lan.siddhu.dev For every New server you must add labels and networks in container labels: - \"traefik.enable=true\" - \"traefik.http.routers.dozzle.rule=Host(`dozzle.lan.siddhu.dev`)\" - \"traefik.http.routers.dozzle.entrypoints=websecure\" - \"traefik.http.routers.dozzle.tls.certresolver=letsencrypt\" - \"traefik.http.routers.dozzle.tls=true\" - \"traefik.http.routers.dozzle.middlewares=authelia@docker\" - \"traefik.http.services.dozzle.loadbalancer.server.port=8080\" - \"traefik.docker.network=traefik-public\" networks: - traefik-public And network under service networks: traefik-public: external: true Adding authentication using Authelia Install Authelia","title":"The Traefik - Authelia Docker SSO Stack"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/the-traefik-stack/#the-traefik-authelia-docker-sso-stack","text":"","title":"The Traefik - Authelia Docker SSO Stack"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/the-traefik-stack/#what-is-traefik","text":"The simplest, most comprehensive cloud-native stack to help enterprises manage their entire network across data centers, on-premises servers and public clouds all the way out to the edge. Traefik Official Website","title":"What is Traefik?"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/the-traefik-stack/#why-should-you-use-it","text":"If you want to run several containers on a single server and have more than one of them respond to web traffic, you have to use a reverse proxy like Traefik.","title":"Why should you use it?"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/the-traefik-stack/#basics","text":"","title":"Basics"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/the-traefik-stack/#traefik-providers","text":"Traefik supports different types of providers to supply configuration to it. We are using Docker provider and File provider here.","title":"Traefik Providers"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/the-traefik-stack/#docker-provider","text":"It is used to configure our proxy through Docker labels.","title":"Docker Provider"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/the-traefik-stack/#file-provider","text":"Since Docker provider does not support proxying external URLs we are using the file provider.","title":"File Provider"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/the-traefik-stack/#prerequisite","text":"A Machine with docker and docker-compose installed Cloudflare account (Optional). Portainer (Optional) Running Home Assistant Docker stack Lots of patience","title":"Prerequisite"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/the-traefik-stack/#my-setup","text":"Raspberry Pi 4 - 4G running DietPi WD Green 240 GB SSD Connected Amazon Orico Enclosure USB3.1 Gen 2 Amazon Connected via Ethernet","title":"My setup"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/the-traefik-stack/#traefik-installation","text":"My storage location will be /mnt/dietpi_userdata/traefik The domain I will be using is lan.siddhu.dev","title":"Traefik Installation"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/the-traefik-stack/#get-cloudflare-token","text":"Login to CloudFlare Click on the User Icon on the right top. Navigate to API Tokens . Click on Vew next to Global API Key . Complete captcha if shown. Copy the key to use with stack below.","title":"Get CloudFlare token"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/the-traefik-stack/#create-a-dedicated-network-for-connecting-all-containers-and-stacks","text":"$ sudo docker network create --driver=bridge --attachable traefik-public 725626e1ece9d2b292a551c441140a94c23a24588860022998ebf83f9b403cf7 You can create a network in Portainer from Networks -> Add Network , Select Driver Bridge, and turn on Enable manual container attachment","title":"Create a dedicated network for connecting all containers and stacks"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/the-traefik-stack/#create-traefik-stack","text":"Important Notes: The Traefik itself will be using traefik.lan.siddhu.dev domain . Traefik requires you to define \"Certificate Resolvers\" in the configuration, which is responsible for retrieving certificates from an ACME server. We will be using the resolver name letsencrypt , just a name you can use anything. The configuration below is used to create a wildcard cert for all domains under lan.siddhu.dev since LetsEncrypt comes with rate limits . - 'traefik.http.routers.traefik.tls.domains[0].main=lan.siddhu.dev' - 'traefik.http.routers.traefik.tls.domains[0].sans=*.lan.siddhu.dev' In Dynamic Configuration local-ip should be replaced with your Raspberry Pi / VM IP, this once is used for proxying all the devices running in the docker host network. All docker containers are configured through the Portainer itself.","title":"Create Traefik stack"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/the-traefik-stack/#create-folders","text":"mkdir -p /mnt/dietpi_userdata/traefik/confs nano /mnt/dietpi_userdata/traefik/confs/traefik.yml ## traefik.yml # Docker configuration backend providers: docker: endpoint: \"unix:///var/run/docker.sock\" exposedByDefault: false file: directory: \"/etc/traefik\" watch: true # API and dashboard configuration api: insecure: true entryPoints: web: address: \":80\" http: redirections: # Force redirect to https entryPoint: permanent: true to: websecure scheme: https websecure: address: \":443\" certificatesResolvers: letsencrypt: acme: #caServer: https://acme-staging-v02.api.letsencrypt.org/directory storage: /letsencrypt/acme.json email: your-email@gmail.com dnschallenge: provider: cloudflare ## DYNAMIC CONFIGURATION http: routers: esphome: rule: \"Host(`esphome.lan.siddhu.dev`)\" service: esphome-service priority: 1000 tls: certresolver: letsencrypt entryPoints: - websecure homeassistant: rule: \"Host(`ha.lan.siddhu.dev`)\" service: homeassistant-service priority: 1000 tls: certresolver: letsencrypt entryPoints: - websecure services: esphome-service: loadBalancer: servers: - url: \"http://local-ip:6052\" homeassistant-service: loadBalancer: servers: - url: \"http://local-ip:8123\" Create a new stack named traefik in portainer version: \"3.3\" services: traefik: image: \"traefik:v2.5\" container_name: \"traefik\" labels: - 'traefik.enable=true' - 'traefik.http.routers.traefik.rule=Host(`traefik.lan.siddhu.dev`)' - 'traefik.http.routers.traefik.entrypoints=websecure' - \"traefik.http.routers.traefik.tls.certresolver=letsencrypt\" - 'traefik.http.routers.traefik.tls=true' - 'traefik.http.routers.traefik.tls.domains[0].main=lan.siddhu.dev' - 'traefik.http.routers.traefik.tls.domains[0].sans=*.lan.siddhu.dev' - 'traefik.http.services.traefik.loadbalancer.server.port=8080' - \"traefik.docker.network=traefik-public\" environment: - \"CF_API_EMAIL=your-email@gmail.com\" - \"CF_API_KEY=cloudflare-api-key-here\" ports: - \"80:80\" - \"443:443\" - \"8080:8080\" volumes: - \"/mnt/dietpi_userdata/traefik/letsencrypt:/letsencrypt\" # used for storing certifcates and l3 related data - \"/mnt/dietpi_userdata/traefik/confs:/etc/traefik\" # file provider for Traefik - \"/var/run/docker.sock:/var/run/docker.sock:ro\" restart: unless-stopped networks: - traefik-public networks: traefik-public: external: true","title":"Create folders"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/the-traefik-stack/#check-with-browser","text":"Open the url traefik.lan.siddhu.dev in browser, it may throw SSL error for few minutes. If it happends try after 1 or 2 minutes. If everything goes well procced to next step","title":"Check with browser"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/the-traefik-stack/#creating-a-new-proxy-with-traefik","text":"Dozzle is a log viewer for docker containers. Let deploy one with SSL cert in Treafik version: \"3\" services: dozzle: container_name: dozzle image: amir20/dozzle:latest volumes: - /var/run/docker.sock:/var/run/docker.sock #ports: # - 9999:8080 labels: - \"traefik.enable=true\" - \"traefik.http.routers.dozzle.rule=Host(`dozzle.lan.siddhu.dev`)\" - \"traefik.http.routers.dozzle.entrypoints=websecure\" - \"traefik.http.routers.dozzle.tls.certresolver=letsencrypt\" - \"traefik.http.routers.dozzle.tls=true\" - \"traefik.http.routers.dozzle.middlewares=authelia@docker\" - \"traefik.http.services.dozzle.loadbalancer.server.port=8080\" - \"traefik.docker.network=traefik-public\" restart: unless-stopped networks: - traefik-public networks: traefik-public: external: true Within a few seconds it will appear on Traefik dashboard and you can use it with the URL dozzle.lan.siddhu.dev","title":"Creating a new Proxy with Traefik"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/the-traefik-stack/#for-every-new-server-you-must-add-labels-and-networks-in-container","text":"labels: - \"traefik.enable=true\" - \"traefik.http.routers.dozzle.rule=Host(`dozzle.lan.siddhu.dev`)\" - \"traefik.http.routers.dozzle.entrypoints=websecure\" - \"traefik.http.routers.dozzle.tls.certresolver=letsencrypt\" - \"traefik.http.routers.dozzle.tls=true\" - \"traefik.http.routers.dozzle.middlewares=authelia@docker\" - \"traefik.http.services.dozzle.loadbalancer.server.port=8080\" - \"traefik.docker.network=traefik-public\" networks: - traefik-public And network under service networks: traefik-public: external: true","title":"For every New server you must add labels and networks in container"},{"location":"docker-and-self-hosted-apps/the-traefik-stack/the-traefik-stack/#adding-authentication-using-authelia","text":"Install Authelia","title":"Adding authentication using Authelia"},{"location":"esphome/","text":"All ESPHome related posts","title":"ESPHome"},{"location":"esphome/cheap-reliable-pir/","text":"Building a cheap and reliable PIR system with ESPHome This guide explains how to build a powered WiFi PIR system in your house. If you are looking to build a battery powered system, then WiFi is probably the wrong choice and you should look elsewhere. Note: If you are using the slightly expensive PaPIR, you neither need the Power supply mod nor the noise mod. Components needed Any ESP device PSU for powering up ESP PIR Sensor: HC SR501 Ceramic capacitor: 47-220nF Steps Power Wire your PSU to power the ESP device. If your power system is 5V, then you don't need any additional steps since that's the power expected from HC SR501. However, if you are using a 3.3V power supply, you need to bypass the onboard regulator on the sensor to directly take in 3.3V input. Reducing noise HC SR501 is prone to noise and can behave erratically if the issues are not solved. Two major problems usually: ESP brings in WiFi noise and PSU noise. First solve the WiFi noise problem since that's more common. Solder your ceramic capacitor on pins 12-13 of the IC on the PIR sensor. Test your setup after fixing the WiFi noise. If it is still erratic after adjusting sensitivity, then you should look at reducing the power supply noise by soldering an electrolytic capacitor on the PSU input to the sensor. Note: Multiple people have tried and failed using the PSU on Smitch bulbs, consider using an additional supply. Configuration files ESPHome YAML binary_sensor: - platform: gpio pin: number: GPIO16 inverted: false name: \"PIR Sensor\" device_class: motion Example HA automation (Generated using Blueprint) alias: Motion-activated Light description: '' use_blueprint: path: homeassistant/motion_light.yaml input: motion_entity: binary_sensor.pir_sensor_hall light_target: device_id: 153528f8b7ba7faa426499554bf2f015 no_motion_wait: 63","title":"ESPHome PIR HC SR501"},{"location":"esphome/cheap-reliable-pir/#building-a-cheap-and-reliable-pir-system-with-esphome","text":"This guide explains how to build a powered WiFi PIR system in your house. If you are looking to build a battery powered system, then WiFi is probably the wrong choice and you should look elsewhere. Note: If you are using the slightly expensive PaPIR, you neither need the Power supply mod nor the noise mod.","title":"Building a cheap and reliable PIR system with ESPHome"},{"location":"esphome/cheap-reliable-pir/#components-needed","text":"Any ESP device PSU for powering up ESP PIR Sensor: HC SR501 Ceramic capacitor: 47-220nF","title":"Components needed"},{"location":"esphome/cheap-reliable-pir/#steps","text":"","title":"Steps"},{"location":"esphome/cheap-reliable-pir/#power","text":"Wire your PSU to power the ESP device. If your power system is 5V, then you don't need any additional steps since that's the power expected from HC SR501. However, if you are using a 3.3V power supply, you need to bypass the onboard regulator on the sensor to directly take in 3.3V input.","title":"Power"},{"location":"esphome/cheap-reliable-pir/#reducing-noise","text":"HC SR501 is prone to noise and can behave erratically if the issues are not solved. Two major problems usually: ESP brings in WiFi noise and PSU noise. First solve the WiFi noise problem since that's more common. Solder your ceramic capacitor on pins 12-13 of the IC on the PIR sensor. Test your setup after fixing the WiFi noise. If it is still erratic after adjusting sensitivity, then you should look at reducing the power supply noise by soldering an electrolytic capacitor on the PSU input to the sensor. Note: Multiple people have tried and failed using the PSU on Smitch bulbs, consider using an additional supply.","title":"Reducing noise"},{"location":"esphome/cheap-reliable-pir/#configuration-files","text":"ESPHome YAML binary_sensor: - platform: gpio pin: number: GPIO16 inverted: false name: \"PIR Sensor\" device_class: motion Example HA automation (Generated using Blueprint) alias: Motion-activated Light description: '' use_blueprint: path: homeassistant/motion_light.yaml input: motion_entity: binary_sensor.pir_sensor_hall light_target: device_id: 153528f8b7ba7faa426499554bf2f015 no_motion_wait: 63","title":"Configuration files"},{"location":"esphome/Panasonic%20PIR/","text":"Building a reliable PIR Sensor with ESPHome and Panasonic PIR This guide explains how to build a pir sensor with a highly reliable Panasonic PIR sensors. This is an example sensor used throughout this guide: {:target=\"_blank\"} Note: Make sure you use 3.3V input on the PaPir, in order to avoid damage to the D1 Mini Components Needed D1 Mini, or any ESP8266 Chip/Board Panasonic PIR Power Supply (any HLK or a mobile charger) Panasonic PIR Steps Powering your Sensor Use either 5V or 3.3V connectors with D1 Mini With a D1 Mini, it is recomended to power the system through D1 Mini's USB port. Connect the PaPIR only from 3V (from the D1 Mini), so that its output signal will remain within the 3V tolerance Connecting the Sensor Connect the output pin of PaPIR to D0 of the ESP8266, or D1 Mini - this instruction is specific to ESP8266 Connect the VCC on the PIR to 3.3V of D1 Mini or another 3.3V power source if you have available Connect the GND pin of the PIR to G ESPHome Configuration This configuration makes use of the pinmode INPUT_PULLDOWN_16 , which is a special pulldown mode used with D0 (GPIO16) on ESP8266 chips. The configuration adds a 20 second delay in reporting a clear since for usability purposes. You can delete this, increase, or decrease the delay as per your needs ESPHome YAML binary_sensor: - platform: gpio id: my_motion name: \"Panasonic Motion Sensor\" pin: number: 16 inverted: false mode: INPUT_PULLDOWN_16 device_class: motion filters: - delayed_off: 20s Trouble Shooting The Panasonic PIR Sensor implementation is pretty straight forward If you have problems connecting with the sensor, double check connections and pins. Sensor pin with plated or covered/sealed base is GND Double check if Sensor's VCC and Signal/OUT is switched INPUT_PULLDOWN_16 only works with GPIO16, or D0","title":"ESPHome PaPIR"},{"location":"esphome/Panasonic%20PIR/#building-a-reliable-pir-sensor-with-esphome-and-panasonic-pir","text":"This guide explains how to build a pir sensor with a highly reliable Panasonic PIR sensors. This is an example sensor used throughout this guide: {:target=\"_blank\"} Note: Make sure you use 3.3V input on the PaPir, in order to avoid damage to the D1 Mini","title":"Building a reliable PIR Sensor with ESPHome and Panasonic PIR"},{"location":"esphome/Panasonic%20PIR/#components-needed","text":"D1 Mini, or any ESP8266 Chip/Board Panasonic PIR Power Supply (any HLK or a mobile charger)","title":"Components Needed"},{"location":"esphome/Panasonic%20PIR/#panasonic-pir","text":"","title":"Panasonic PIR"},{"location":"esphome/Panasonic%20PIR/#steps","text":"","title":"Steps"},{"location":"esphome/Panasonic%20PIR/#powering-your-sensor","text":"Use either 5V or 3.3V connectors with D1 Mini With a D1 Mini, it is recomended to power the system through D1 Mini's USB port. Connect the PaPIR only from 3V (from the D1 Mini), so that its output signal will remain within the 3V tolerance","title":"Powering your Sensor"},{"location":"esphome/Panasonic%20PIR/#connecting-the-sensor","text":"Connect the output pin of PaPIR to D0 of the ESP8266, or D1 Mini - this instruction is specific to ESP8266 Connect the VCC on the PIR to 3.3V of D1 Mini or another 3.3V power source if you have available Connect the GND pin of the PIR to G","title":"Connecting the Sensor"},{"location":"esphome/Panasonic%20PIR/#esphome-configuration","text":"This configuration makes use of the pinmode INPUT_PULLDOWN_16 , which is a special pulldown mode used with D0 (GPIO16) on ESP8266 chips. The configuration adds a 20 second delay in reporting a clear since for usability purposes. You can delete this, increase, or decrease the delay as per your needs","title":"ESPHome Configuration"},{"location":"esphome/Panasonic%20PIR/#esphome-yaml","text":"binary_sensor: - platform: gpio id: my_motion name: \"Panasonic Motion Sensor\" pin: number: 16 inverted: false mode: INPUT_PULLDOWN_16 device_class: motion filters: - delayed_off: 20s","title":"ESPHome YAML"},{"location":"esphome/Panasonic%20PIR/#trouble-shooting","text":"The Panasonic PIR Sensor implementation is pretty straight forward If you have problems connecting with the sensor, double check connections and pins. Sensor pin with plated or covered/sealed base is GND Double check if Sensor's VCC and Signal/OUT is switched INPUT_PULLDOWN_16 only works with GPIO16, or D0","title":"Trouble Shooting"},{"location":"esphome/acs712-current-monitor/","text":"AC current measurement using ACS712 ACS712 is one of the cheapest available current measurement sensor in the market. It operates by returning an analog value proportional to the current being passed with a fairly low response time of 5us. Datasheet Given the output from the sensor is also an analog output, it is tricky to do current calculations on top of this sensor. This is because the output would be similar to the AC waveform input. However, you can use the method below to get a fairly well calibrated system which is quite accurate. The details are based on this well explained research , I will focus only on the final result of using it in your system and not the why, you can read more in the linked tutorial. We will use the final version listed as \"Test 3\" in the tutorial above so it works even with dimmer circuits that use Triacs. Note: This requires adding some additional libraries in your ESPHome config, this can lead to a limited RAM availability. I wasn't able to run BLE monitor when adding these libraries on my ESP32 board. Step 1: Include required libraries Download the filters library and place it in config/esphome/ folder. Step 2: Create custom header file with sensor You can name it as acs_trms.h and again place it in config/esphome/ folder #include \"Filters.h\" class MyTRMSSensor : public PollingComponent, public Sensor { float ACS_Value; //Here we keep the raw data valuess float testFrequency = 50; // test signal frequency (Hz) float windowLength = 120.0/testFrequency; // how long to average the signal, for statistist float intercept = -70; // to be adjusted based on calibration testing float slope = 15.4; // to be adjusted based on calibration testing float Amps_TRMS; // estimated actual current in amps // Track time in milliseconds since last reading unsigned long previousMillis = 0; public: RunningStatistics inputStats = RunningStatistics(); MyTRMSSensor() : PollingComponent(6000) {} float get_setup_priority() const override { return esphome::setup_priority::HARDWARE; } float read_Amps() { return intercept + slope * inputStats.sigma(); } void setup() override { inputStats.setWindowSecs( windowLength ); //Set the window length } void update() override { publish_state(read_Amps()); } void loop() override { ACS_Value = analogRead(35); // read the analog value from pin 35 inputStats.input(ACS_Value); // log to Stats function } }; Step 3: Create ESPHome device YAML file esphome: name: power-strip platform: ESP32 board: esp-wrover-kit includes: - Filters.h - FilterOnePole.h - FilterTwoPole.h - FilterDerivative.h - RunningStatistics.h - FloatDefine.h - FilterOnePole.cpp - FilterTwoPole.cpp - FilterDerivative.cpp - RunningStatistics.cpp - acs_trms.h sensor: - platform: custom lambda: |- auto my_sensor_rms = new MyTRMSSensor(); App.register_component(my_sensor_rms); return {my_sensor_rms}; sensors: name: \"Powerstrip current TRMS\" unit_of_measurement: \"mA\" accuracy_decimals: 2 Step 4: Tuning Use a known load or an existing smart plug and tune your slope and intercept in acs_trms.h . First tune your intercept by having 0 load, and then tune your slope by adding some known load and checking the value you get.","title":"AC current measurement using ACS712"},{"location":"esphome/acs712-current-monitor/#ac-current-measurement-using-acs712","text":"ACS712 is one of the cheapest available current measurement sensor in the market. It operates by returning an analog value proportional to the current being passed with a fairly low response time of 5us. Datasheet Given the output from the sensor is also an analog output, it is tricky to do current calculations on top of this sensor. This is because the output would be similar to the AC waveform input. However, you can use the method below to get a fairly well calibrated system which is quite accurate. The details are based on this well explained research , I will focus only on the final result of using it in your system and not the why, you can read more in the linked tutorial. We will use the final version listed as \"Test 3\" in the tutorial above so it works even with dimmer circuits that use Triacs. Note: This requires adding some additional libraries in your ESPHome config, this can lead to a limited RAM availability. I wasn't able to run BLE monitor when adding these libraries on my ESP32 board.","title":"AC current measurement using ACS712"},{"location":"esphome/acs712-current-monitor/#step-1-include-required-libraries","text":"Download the filters library and place it in config/esphome/ folder.","title":"Step 1: Include required libraries"},{"location":"esphome/acs712-current-monitor/#step-2-create-custom-header-file-with-sensor","text":"You can name it as acs_trms.h and again place it in config/esphome/ folder #include \"Filters.h\" class MyTRMSSensor : public PollingComponent, public Sensor { float ACS_Value; //Here we keep the raw data valuess float testFrequency = 50; // test signal frequency (Hz) float windowLength = 120.0/testFrequency; // how long to average the signal, for statistist float intercept = -70; // to be adjusted based on calibration testing float slope = 15.4; // to be adjusted based on calibration testing float Amps_TRMS; // estimated actual current in amps // Track time in milliseconds since last reading unsigned long previousMillis = 0; public: RunningStatistics inputStats = RunningStatistics(); MyTRMSSensor() : PollingComponent(6000) {} float get_setup_priority() const override { return esphome::setup_priority::HARDWARE; } float read_Amps() { return intercept + slope * inputStats.sigma(); } void setup() override { inputStats.setWindowSecs( windowLength ); //Set the window length } void update() override { publish_state(read_Amps()); } void loop() override { ACS_Value = analogRead(35); // read the analog value from pin 35 inputStats.input(ACS_Value); // log to Stats function } };","title":"Step 2: Create custom header file with sensor"},{"location":"esphome/acs712-current-monitor/#step-3-create-esphome-device-yaml-file","text":"esphome: name: power-strip platform: ESP32 board: esp-wrover-kit includes: - Filters.h - FilterOnePole.h - FilterTwoPole.h - FilterDerivative.h - RunningStatistics.h - FloatDefine.h - FilterOnePole.cpp - FilterTwoPole.cpp - FilterDerivative.cpp - RunningStatistics.cpp - acs_trms.h sensor: - platform: custom lambda: |- auto my_sensor_rms = new MyTRMSSensor(); App.register_component(my_sensor_rms); return {my_sensor_rms}; sensors: name: \"Powerstrip current TRMS\" unit_of_measurement: \"mA\" accuracy_decimals: 2","title":"Step 3: Create ESPHome device YAML file"},{"location":"esphome/acs712-current-monitor/#step-4-tuning","text":"Use a known load or an existing smart plug and tune your slope and intercept in acs_trms.h . First tune your intercept by having 0 load, and then tune your slope by adding some known load and checking the value you get.","title":"Step 4: Tuning"},{"location":"esphome/diy-ir-blaster/diy-ir-blaster/","text":"Create your own IR blaster Why? We still live in a world with a host of devices that use their own remotes. Creating an IR blaster allows you to make these devices smart and control them without picking up your remotes ever again. Can I just buy one? Buying one is easy and you have a few options - Tuya convert supported IR blasters: https://www.amazon.in/gp/product/B07N4LSZF6/ref=ppx_yo_dt_b_search_asin_title?ie=UTF8&psc=1 - Broadlink IR blasters However, note that buying one is significantly more expensive than creating one, plus you can't use those nodes to do anything else. Things to buy An ESP controller Strong IR LED - The general IR LEDs in the market don't have enough range to cover a normal room, buy special purpose Vishay LEDs to get an appropriate range. I tested these LEDs in a 6mX6m area and a single LED worked flawlessly to achieve the range: TSAL4400, 6200 and 6400, 7400. Do read their datasheets to know about their angles and power to decide what's best for you. TSAL4400 for example has a coverage area of 50 degrees so you can cover a pretty wide range. You can buy from: https://veerobot.com/tsal4400-high-power-ir-emitter?search=Tsal&description=true You can possibly have multiple IR LEDs that are pointing in all directions but you really don't need them for most rooms if you use the above ones. Important : You should never place your LEDs close to each other since they can interfere and end up screwing the signal. Use the viewing angle from the datasheet to make a decision. Circuit The maximum current drawn from an ESP pin is of the order of 10mA. While you can drive an IR LED with this current, you are going to get the highest range only when you drive your LEDs with current of the order of ~100mA. You can easily use a transistor 2N2222 the IR LED (in series with a resistor). You can calculate the resistor value by using the voltage drop of the IR Led. eg If your IR LED has a voltage drop of 1.2V and your source voltage is 5V, then your resistor should have a voltage drop of 3.8V. You can then calculate the R value using the desired current. For 100mA, you would need a resistor of 38 ohm. Software I use ESPHome to encode all switches using the IR component but you can potentially use something more generic like Tasmota IR blaster Optional - Add a receiver circuit You can optionally add a receiver to be able to intercept signals from normal remotes so that your smart systems always know about the current state(when you turn on/off using the remote). This isn't really necessary(eg you never use the remote) but a good to have. Note that you can achieve the same using an IR receiever rather than a TSOP, but a TSOP is significantly less error prone and does filtering for you so no reason to not use one. Buy link: https://www.amazon.in/TSOP-1738-IR-RECEIVER-PCS/dp/B07B6QMZ4G You can then add your receiver in ESPHome as well using the IR component: https://esphome.io/components/remote_receiver.html","title":"Create your own IR blaster"},{"location":"esphome/diy-ir-blaster/diy-ir-blaster/#create-your-own-ir-blaster","text":"","title":"Create your own IR blaster"},{"location":"esphome/diy-ir-blaster/diy-ir-blaster/#why","text":"We still live in a world with a host of devices that use their own remotes. Creating an IR blaster allows you to make these devices smart and control them without picking up your remotes ever again.","title":"Why?"},{"location":"esphome/diy-ir-blaster/diy-ir-blaster/#can-i-just-buy-one","text":"Buying one is easy and you have a few options - Tuya convert supported IR blasters: https://www.amazon.in/gp/product/B07N4LSZF6/ref=ppx_yo_dt_b_search_asin_title?ie=UTF8&psc=1 - Broadlink IR blasters However, note that buying one is significantly more expensive than creating one, plus you can't use those nodes to do anything else.","title":"Can I just buy one?"},{"location":"esphome/diy-ir-blaster/diy-ir-blaster/#things-to-buy","text":"An ESP controller Strong IR LED - The general IR LEDs in the market don't have enough range to cover a normal room, buy special purpose Vishay LEDs to get an appropriate range. I tested these LEDs in a 6mX6m area and a single LED worked flawlessly to achieve the range: TSAL4400, 6200 and 6400, 7400. Do read their datasheets to know about their angles and power to decide what's best for you. TSAL4400 for example has a coverage area of 50 degrees so you can cover a pretty wide range. You can buy from: https://veerobot.com/tsal4400-high-power-ir-emitter?search=Tsal&description=true You can possibly have multiple IR LEDs that are pointing in all directions but you really don't need them for most rooms if you use the above ones. Important : You should never place your LEDs close to each other since they can interfere and end up screwing the signal. Use the viewing angle from the datasheet to make a decision.","title":"Things to buy"},{"location":"esphome/diy-ir-blaster/diy-ir-blaster/#circuit","text":"The maximum current drawn from an ESP pin is of the order of 10mA. While you can drive an IR LED with this current, you are going to get the highest range only when you drive your LEDs with current of the order of ~100mA. You can easily use a transistor 2N2222 the IR LED (in series with a resistor). You can calculate the resistor value by using the voltage drop of the IR Led. eg If your IR LED has a voltage drop of 1.2V and your source voltage is 5V, then your resistor should have a voltage drop of 3.8V. You can then calculate the R value using the desired current. For 100mA, you would need a resistor of 38 ohm.","title":"Circuit"},{"location":"esphome/diy-ir-blaster/diy-ir-blaster/#software","text":"I use ESPHome to encode all switches using the IR component but you can potentially use something more generic like Tasmota IR blaster","title":"Software"},{"location":"esphome/diy-ir-blaster/diy-ir-blaster/#optional-add-a-receiver-circuit","text":"You can optionally add a receiver to be able to intercept signals from normal remotes so that your smart systems always know about the current state(when you turn on/off using the remote). This isn't really necessary(eg you never use the remote) but a good to have. Note that you can achieve the same using an IR receiever rather than a TSOP, but a TSOP is significantly less error prone and does filtering for you so no reason to not use one. Buy link: https://www.amazon.in/TSOP-1738-IR-RECEIVER-PCS/dp/B07B6QMZ4G You can then add your receiver in ESPHome as well using the IR component: https://esphome.io/components/remote_receiver.html","title":"Optional - Add a receiver circuit"},{"location":"homeassistant/","text":"","title":"HomeAssistant"},{"location":"homeassistant/multi-click-actions/","text":"Creating Automations for multi click actions There are instances where the external inputs like buttons often have single or double actions, and more is needed. This can be achieved via some smart automations automations.yaml - alias: \"zb_button_actions\" id: zb_button_actions mode: restart trigger: - platform: state entity_id: sensor.zb_button_action to: - single - double condition: [] action: - repeat: count: \"{{ 1 if trigger.to_state.state == 'single' else 2 if trigger.to_state.state == 'double' }}\" sequence: - service: counter.increment target: entity_id: counter.click_counter - delay: # supports seconds, milliseconds, minutes, hours milliseconds: 1000 - service: persistent_notification.create data: message: test {{ trigger.to_state.state }} - service: counter.reset target: entity_id: counter.click_counter - alias: \"double_click_action\" id: double_click_action mode: single trigger: - platform: state entity_id: counter.click_counter to: \"2\" for: seconds: 1 condition: [] action: - service: input_number.set_value target: entity_id: input_number.double_click_display data: value: 2 - delay: seconds: 2 - service: input_number.set_value target: entity_id: input_number.double_click_display data: value: 0 - alias: \"triple_click_action\" id: triple_click_action mode: single trigger: - platform: state entity_id: counter.click_counter to: \"3\" for: seconds: 1 condition: [] action: - service: input_number.set_value target: entity_id: input_number.triple_click_display data: value: 3 - delay: seconds: 2 - service: input_number.set_value target: entity_id: input_number.triple_click_display data: value: 0 Summary: 1. zb_button_actions is the primary automation which captures any button event, for example 'single' (can be anything) and starts of a counter. This counter is incremented until certain duration - delay of 1000 ms here. After this delay, the counter is reset, ready for next cycle of input 2. The \"double_click_action\" watches the state of the click counter for the count value of 2 which should not change until certain duration - 1 second here and triggers respective actions. Note: You might want to play around with the delay duration mentioned in \"zb_button_actions\" and match against it. 3. Similarly for \"triple_click_action\", the state of the counter is observed for count value of 3. The delay for: seconds: 1 plays a critical part - when a counter is incrementing in zb_button_actions, it might invoke \"double_click_action\" event when it reaches count value of 2. Hence the need for min duration for delay defined in zb_button_actions (and kind of match the delay in zb_button_actions) . However, if the duration of delay put is relatively higher - say 1.5 /2 seconds in this example, this will not trigger the triple_click_action, as the click_counter will be reset to 0 after 1 second. You can define more \"click_actions\" based on delay duration to wait for all the clicks in zb_button_actions. It will also be based on how your setup performance is and your comfortability in getting the number of clicks within that delay duraton. In my testing, three clicks are easily possible using Sonoff Button by invoking single press three times within 1 sec / 1000 ms. Please do tinker around to get your comfortability 4. The following actions in \"double_click_action\" and \"triple_click_action\" are not needed, they are just so that in the UI, the input number slider value could be reset after they are triggered for better visual feedback - delay: seconds: 2 - service: input_number.set_value target: entity_id: input_number.double_click_display data: value: 0","title":"Index"},{"location":"homeassistant/multi-click-actions/#creating-automations-for-multi-click-actions","text":"There are instances where the external inputs like buttons often have single or double actions, and more is needed. This can be achieved via some smart automations automations.yaml - alias: \"zb_button_actions\" id: zb_button_actions mode: restart trigger: - platform: state entity_id: sensor.zb_button_action to: - single - double condition: [] action: - repeat: count: \"{{ 1 if trigger.to_state.state == 'single' else 2 if trigger.to_state.state == 'double' }}\" sequence: - service: counter.increment target: entity_id: counter.click_counter - delay: # supports seconds, milliseconds, minutes, hours milliseconds: 1000 - service: persistent_notification.create data: message: test {{ trigger.to_state.state }} - service: counter.reset target: entity_id: counter.click_counter - alias: \"double_click_action\" id: double_click_action mode: single trigger: - platform: state entity_id: counter.click_counter to: \"2\" for: seconds: 1 condition: [] action: - service: input_number.set_value target: entity_id: input_number.double_click_display data: value: 2 - delay: seconds: 2 - service: input_number.set_value target: entity_id: input_number.double_click_display data: value: 0 - alias: \"triple_click_action\" id: triple_click_action mode: single trigger: - platform: state entity_id: counter.click_counter to: \"3\" for: seconds: 1 condition: [] action: - service: input_number.set_value target: entity_id: input_number.triple_click_display data: value: 3 - delay: seconds: 2 - service: input_number.set_value target: entity_id: input_number.triple_click_display data: value: 0 Summary: 1. zb_button_actions is the primary automation which captures any button event, for example 'single' (can be anything) and starts of a counter. This counter is incremented until certain duration - delay of 1000 ms here. After this delay, the counter is reset, ready for next cycle of input 2. The \"double_click_action\" watches the state of the click counter for the count value of 2 which should not change until certain duration - 1 second here and triggers respective actions. Note: You might want to play around with the delay duration mentioned in \"zb_button_actions\" and match against it. 3. Similarly for \"triple_click_action\", the state of the counter is observed for count value of 3. The delay for: seconds: 1 plays a critical part - when a counter is incrementing in zb_button_actions, it might invoke \"double_click_action\" event when it reaches count value of 2. Hence the need for min duration for delay defined in zb_button_actions (and kind of match the delay in zb_button_actions) . However, if the duration of delay put is relatively higher - say 1.5 /2 seconds in this example, this will not trigger the triple_click_action, as the click_counter will be reset to 0 after 1 second. You can define more \"click_actions\" based on delay duration to wait for all the clicks in zb_button_actions. It will also be based on how your setup performance is and your comfortability in getting the number of clicks within that delay duraton. In my testing, three clicks are easily possible using Sonoff Button by invoking single press three times within 1 sec / 1000 ms. Please do tinker around to get your comfortability 4. The following actions in \"double_click_action\" and \"triple_click_action\" are not needed, they are just so that in the UI, the input number slider value could be reset after they are triggered for better visual feedback - delay: seconds: 2 - service: input_number.set_value target: entity_id: input_number.double_click_display data: value: 0","title":"Creating Automations for multi click actions"},{"location":"homeassistant/remote-access/","text":"Remotely access your home assistant instance for free Note: If you can afford and are willing to support HomeAssistant development, consider using a subscription to Nabu Casa which provides you Remote access + Alexa / Google Assistant support for $5 / month. Only remote access You can simply use a private VPN setup to have access to your instance. No open ports needed on your network. ZeroTier: https://www.zerotier.com/ TailScale: https://tailscale.com/ If you have a public IP, you can also build your own VPN network using something like OpenVPN: https://openvpn.net/ Only Alexa / Google Assistant NodeRed - TBD Remote access + Alexa / Google Assistant The best way to have both is to have your instance exposed to the internet: - If you have a public IP, then you can simply open relevant ports on your network and use your IP. - Most ISPs in India will not provide you a public IP, so you require to build a tunnel from the internet to your instance. Tunneling options Dataplicity (Disadvantage: No E2E TLS, Dataplicity folks can see your data) nGrok (Disadvantage: URL changes everytime your tunnel stops - Restarts / Internet losses) Pagekite (Disadvantage: You need to request for trial extension every month) DIY: Use a free VPS with Tunnelling","title":"Index"},{"location":"homeassistant/remote-access/#remotely-access-your-home-assistant-instance-for-free","text":"Note: If you can afford and are willing to support HomeAssistant development, consider using a subscription to Nabu Casa which provides you Remote access + Alexa / Google Assistant support for $5 / month.","title":"Remotely access your home assistant instance for free"},{"location":"homeassistant/remote-access/#only-remote-access","text":"You can simply use a private VPN setup to have access to your instance. No open ports needed on your network. ZeroTier: https://www.zerotier.com/ TailScale: https://tailscale.com/ If you have a public IP, you can also build your own VPN network using something like OpenVPN: https://openvpn.net/","title":"Only remote access"},{"location":"homeassistant/remote-access/#only-alexa-google-assistant","text":"NodeRed - TBD","title":"Only Alexa / Google Assistant"},{"location":"homeassistant/remote-access/#remote-access-alexa-google-assistant","text":"The best way to have both is to have your instance exposed to the internet: - If you have a public IP, then you can simply open relevant ports on your network and use your IP. - Most ISPs in India will not provide you a public IP, so you require to build a tunnel from the internet to your instance.","title":"Remote access + Alexa / Google Assistant"},{"location":"homeassistant/remote-access/#tunneling-options","text":"Dataplicity (Disadvantage: No E2E TLS, Dataplicity folks can see your data) nGrok (Disadvantage: URL changes everytime your tunnel stops - Restarts / Internet losses) Pagekite (Disadvantage: You need to request for trial extension every month) DIY: Use a free VPS with Tunnelling","title":"Tunneling options"},{"location":"nvr-and-surveillance/","text":"All NVR / Surveillance / Object and motion detection related posts","title":"NVR"},{"location":"nvr-and-surveillance/zoneminder/","text":"ZoneMinder Zoneminder is a long runnng reliable project for setting up NVR. Installation Docker is the easiest way to setup ZoneMinder. docker-compose.yaml zoneminder: container_name: zoneminder image: dlandon/zoneminder:latest restart: 'no' shm_size: '1gb' ports: - 8443:443/tcp - 9000:9000/tcp network_mode: \"bridge\" environment: - TZ=Asia/Kolkata - SHMEM=50% - PUID=99 - PGID=100 - INSTALL_HOOK=0 - INSTALL_FACE=0 - INSTALL_TINY_YOLOV3=1 - INSTALL_YOLOV3=1 - INSTALL_TINY_YOLOV4=1 - INSTALL_YOLOV4=1 - MULTI_PORT_START=0 - MULTI_PORT_END=0 volumes: - ./config:/config:rw - ./data:/var/cache/zoneminder:rw Home Assistant integration Home Assistant supports Native camera integration with ZoneMinder cameras. Add this to your configuration.yaml zoneminder: host: <URL>:<PORT> verify_ssl: false ssl: true camera: - platform: zoneminder Now you can add all your cameras to your lovelace dashboard. Detecting Camera events on ZoneMinder The ZoneMinder docker install ships with EventServer notificiation system which can be used to generate events. Setup your EventServer by editing the file in the /config folder: Documentation Reference Getting events on ZMNinja App The above config is sufficient to receive notifications on ZMNinja. Notifications still work when you are not in the same network but you will need to use ZeroTier / Tailscale / Publicly accessible ZoneMinder instance when you open the app. Getting events on Home Assistant (MQTT) Getting MQTT to work requires additional installation of MQTT Perl libraries. Log into the docker instance using docker exec --it <container_name> /bin/bash Install the library perl -MCPAN -e \"install Net::MQTT::Simple\" . You might see an error saying make not found , you might need to install it first using apt install make Enable MQTT in the configuration file: Reference documentation Now you can create sensors using the MQTT information publised by ZoneMinder. For instance, create a Motion detection sensor using binary_sensor: - platform: mqtt state_topic: \"zoneminder/1\" name: ZM camera value_template: '{% if value_json.state == \"alarm\" and value_json.eventtype == \"event_start\" %} ON {% else %} OFF {% endif %}' device_class: motion","title":"Index"},{"location":"nvr-and-surveillance/zoneminder/#zoneminder","text":"Zoneminder is a long runnng reliable project for setting up NVR.","title":"ZoneMinder"},{"location":"nvr-and-surveillance/zoneminder/#installation","text":"Docker is the easiest way to setup ZoneMinder. docker-compose.yaml zoneminder: container_name: zoneminder image: dlandon/zoneminder:latest restart: 'no' shm_size: '1gb' ports: - 8443:443/tcp - 9000:9000/tcp network_mode: \"bridge\" environment: - TZ=Asia/Kolkata - SHMEM=50% - PUID=99 - PGID=100 - INSTALL_HOOK=0 - INSTALL_FACE=0 - INSTALL_TINY_YOLOV3=1 - INSTALL_YOLOV3=1 - INSTALL_TINY_YOLOV4=1 - INSTALL_YOLOV4=1 - MULTI_PORT_START=0 - MULTI_PORT_END=0 volumes: - ./config:/config:rw - ./data:/var/cache/zoneminder:rw","title":"Installation"},{"location":"nvr-and-surveillance/zoneminder/#home-assistant-integration","text":"Home Assistant supports Native camera integration with ZoneMinder cameras. Add this to your configuration.yaml zoneminder: host: <URL>:<PORT> verify_ssl: false ssl: true camera: - platform: zoneminder Now you can add all your cameras to your lovelace dashboard.","title":"Home Assistant integration"},{"location":"nvr-and-surveillance/zoneminder/#detecting-camera-events-on-zoneminder","text":"The ZoneMinder docker install ships with EventServer notificiation system which can be used to generate events. Setup your EventServer by editing the file in the /config folder: Documentation Reference","title":"Detecting Camera events on ZoneMinder"},{"location":"nvr-and-surveillance/zoneminder/#getting-events-on-zmninja-app","text":"The above config is sufficient to receive notifications on ZMNinja. Notifications still work when you are not in the same network but you will need to use ZeroTier / Tailscale / Publicly accessible ZoneMinder instance when you open the app.","title":"Getting events on ZMNinja App"},{"location":"nvr-and-surveillance/zoneminder/#getting-events-on-home-assistant-mqtt","text":"Getting MQTT to work requires additional installation of MQTT Perl libraries. Log into the docker instance using docker exec --it <container_name> /bin/bash Install the library perl -MCPAN -e \"install Net::MQTT::Simple\" . You might see an error saying make not found , you might need to install it first using apt install make Enable MQTT in the configuration file: Reference documentation Now you can create sensors using the MQTT information publised by ZoneMinder. For instance, create a Motion detection sensor using binary_sensor: - platform: mqtt state_topic: \"zoneminder/1\" name: ZM camera value_template: '{% if value_json.state == \"alarm\" and value_json.eventtype == \"event_start\" %} ON {% else %} OFF {% endif %}' device_class: motion","title":"Getting events on Home Assistant (MQTT)"},{"location":"tasmota/","text":"All Tasmota related posts","title":"Tasmota"},{"location":"tasmota/basic-settings-and-setoptions/","text":"Basic Settings and Setoptions After setting up 'fresh' Tasmota on a device, the following SetOptions (SO) and Settings may be considered; Usage: SOXX 1 to activate and SOXX 0 to deactivate the desired SO. These should be entered in the tasmota console. SO65 1 To disable Device recovery using fast power cycle detection. Use this if your device reverts to AP mode after a voltage fluctuation cycle. Alert: This takes away the ability for fast power cycle detection (Power the device on and off six times with intervals lower than 10 seconds and leave it on after seventh time) to reset the device. SO1 1 To disable inadvertent device reset due to long press of a 'Button'. Timezone +05:30 To set Tasmota time to IST. SO56 1 Wi-Fi network scan to select strongest signal on device restart (network has to be visible).","title":"Index"},{"location":"tasmota/basic-settings-and-setoptions/#basic-settings-and-setoptions","text":"After setting up 'fresh' Tasmota on a device, the following SetOptions (SO) and Settings may be considered; Usage: SOXX 1 to activate and SOXX 0 to deactivate the desired SO. These should be entered in the tasmota console. SO65 1 To disable Device recovery using fast power cycle detection. Use this if your device reverts to AP mode after a voltage fluctuation cycle. Alert: This takes away the ability for fast power cycle detection (Power the device on and off six times with intervals lower than 10 seconds and leave it on after seventh time) to reset the device. SO1 1 To disable inadvertent device reset due to long press of a 'Button'. Timezone +05:30 To set Tasmota time to IST. SO56 1 Wi-Fi network scan to select strongest signal on device restart (network has to be visible).","title":"Basic Settings and Setoptions"},{"location":"tracking/","text":"All posts related to tracking: Indoor / Outdoor","title":"Tracking"},{"location":"tracking/indoor-ble-tracking/","text":"Indoor BLE tracking Why? Track your pets, kids around the house using a cheap BLE tracker(https://robu.in/product/smart-mini-gps-tracker-anti-lost-waterproof-bluetoothtracer-for-pet-kidsgreen) or using Tile(https://www.amazon.in/Tile-Mate-Key-Finder-Phone/dp/B01L3VEC08) Find your keys / wallet and which room are they in? Automate and take actions using smartwatch / mobile tracking How? There are multiple solutions in the market, use the solution that works best for you. Room assistant has a comprehensive wiki explaining the differences between different solutions(https://www.room-assistant.io/guide/#why-not) My setup Room assistant running on Odroid(HA server using addon) and my linux server(NodeJS install). Presence detection running on ESP32 nodes all around the house using ESPHome I use a hybrid mechanism of using states from both ESP32 and RoomAssistant to find the location of the tracker. See section below Tracking with ESP32 + RoomAssistant Setup Running ESPHome on ESP nodes with BLE tracker integration: https://esphome.io/components/esp32_ble_tracker.html Running Room assistant with MQTT enabled. https://www.room-assistant.io/integrations/mqtt.html#message-format Configuration Room assistant: We will create a sensor which listens to the BLE RSSI values reported by Room assistant in HA configuration.yaml. sensor: - platform: mqtt state_topic: \"room-assistant/entity/<roomAssistantNodeId>/bluetooth-low-energy-presence-sensor/<trackerId>\" name: \"Bedroom tracker RSSI\" value_template: \"{{ value_json.entity.measuredValues.<roomAssistantNodeId>.rssi }}\" unit_of_measurement: dB ESPHome: We get a sensor by declaring in espHome.yml sensor: - platform: ble_rssi mac_address: AC:37:43:77:5F:4C name: \"Hall tracker RSSI\" We will now define a composite sensor which depends on the above sensors in HA configuration.yaml template: sensor: - name: \"Tracker location\" state: > {% set sensors = ['sensor.bedroom_tracker_rssi', 'sensor.hall_tracker_rssi'] %} {% set sensorsNames = ['Bedroom', 'Hall'] %} {% set data = namespace(new_list=[]) %} {% for sensor in sensors %} {% set data.new_list = data.new_list + [states(sensor)] %} {% endfor %} {% set min_rssi = min(data.new_list) %} {% set sensor_id = data.new_list.index(min_rssi) %} {{ sensorsNames[sensor_id] }}","title":"Indoor BLE tracking"},{"location":"tracking/indoor-ble-tracking/#indoor-ble-tracking","text":"","title":"Indoor BLE tracking"},{"location":"tracking/indoor-ble-tracking/#why","text":"Track your pets, kids around the house using a cheap BLE tracker(https://robu.in/product/smart-mini-gps-tracker-anti-lost-waterproof-bluetoothtracer-for-pet-kidsgreen) or using Tile(https://www.amazon.in/Tile-Mate-Key-Finder-Phone/dp/B01L3VEC08) Find your keys / wallet and which room are they in? Automate and take actions using smartwatch / mobile tracking","title":"Why?"},{"location":"tracking/indoor-ble-tracking/#how","text":"There are multiple solutions in the market, use the solution that works best for you. Room assistant has a comprehensive wiki explaining the differences between different solutions(https://www.room-assistant.io/guide/#why-not)","title":"How?"},{"location":"tracking/indoor-ble-tracking/#my-setup","text":"Room assistant running on Odroid(HA server using addon) and my linux server(NodeJS install). Presence detection running on ESP32 nodes all around the house using ESPHome I use a hybrid mechanism of using states from both ESP32 and RoomAssistant to find the location of the tracker. See section below","title":"My setup"},{"location":"tracking/indoor-ble-tracking/#tracking-with-esp32-roomassistant","text":"","title":"Tracking with ESP32 + RoomAssistant"},{"location":"tracking/indoor-ble-tracking/#setup","text":"Running ESPHome on ESP nodes with BLE tracker integration: https://esphome.io/components/esp32_ble_tracker.html Running Room assistant with MQTT enabled. https://www.room-assistant.io/integrations/mqtt.html#message-format","title":"Setup"},{"location":"tracking/indoor-ble-tracking/#configuration","text":"Room assistant: We will create a sensor which listens to the BLE RSSI values reported by Room assistant in HA configuration.yaml. sensor: - platform: mqtt state_topic: \"room-assistant/entity/<roomAssistantNodeId>/bluetooth-low-energy-presence-sensor/<trackerId>\" name: \"Bedroom tracker RSSI\" value_template: \"{{ value_json.entity.measuredValues.<roomAssistantNodeId>.rssi }}\" unit_of_measurement: dB ESPHome: We get a sensor by declaring in espHome.yml sensor: - platform: ble_rssi mac_address: AC:37:43:77:5F:4C name: \"Hall tracker RSSI\" We will now define a composite sensor which depends on the above sensors in HA configuration.yaml template: sensor: - name: \"Tracker location\" state: > {% set sensors = ['sensor.bedroom_tracker_rssi', 'sensor.hall_tracker_rssi'] %} {% set sensorsNames = ['Bedroom', 'Hall'] %} {% set data = namespace(new_list=[]) %} {% for sensor in sensors %} {% set data.new_list = data.new_list + [states(sensor)] %} {% endfor %} {% set min_rssi = min(data.new_list) %} {% set sensor_id = data.new_list.index(min_rssi) %} {{ sensorsNames[sensor_id] }}","title":"Configuration"},{"location":"tracking/vehicle-tracking-st901-traccar/","text":"Vehicle tracking with ST901 tracker and Traccar Why? Self host your location data rather than giving it to Google. Draw beautiful maps of your journeys Detect thefts of your vehicle, Know details of usage after you lend it to someone. Use HA Zones and prescence detection to create automations when you reach / leave the house. How? Vehicle tracking with ST901 tracker and open source server running Traccar. Blog","title":"Vehicle tracking with ST901 tracker and Traccar"},{"location":"tracking/vehicle-tracking-st901-traccar/#vehicle-tracking-with-st901-tracker-and-traccar","text":"","title":"Vehicle tracking with ST901 tracker and Traccar"},{"location":"tracking/vehicle-tracking-st901-traccar/#why","text":"Self host your location data rather than giving it to Google. Draw beautiful maps of your journeys Detect thefts of your vehicle, Know details of usage after you lend it to someone. Use HA Zones and prescence detection to create automations when you reach / leave the house.","title":"Why?"},{"location":"tracking/vehicle-tracking-st901-traccar/#how","text":"Vehicle tracking with ST901 tracker and open source server running Traccar. Blog","title":"How?"}]}